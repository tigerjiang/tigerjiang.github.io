<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>descripation_test</title>
    <url>/2020/09/10/descripation-test/</url>
    <content><![CDATA[<h1 id="技术博客">技术博客</h1>
<h3 id="这是一篇技术博客请大家多多指正">这是一篇技术博客，请大家多多指正</h3>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-begin">Quick Begin</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>[photo] (images/cover1.png) More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>installation</title>
    <url>/2020/09/11/installation-1/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>installation</title>
    <url>/2020/09/11/installation/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>搭建gitlab服务器</title>
    <url>/2020/09/01/%E6%90%AD%E5%BB%BAgitlab%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><strong>搭建Git服务器：使用Docker快速搭建Gitlab</strong></p>
<p>在前面的章节中，我们学习了大量的 Git 命令使用，考虑到降低 Git 学习成本并没有教大家如何去搭建 Git 服务器，因为搭建 Git 服务的场景遇到的机会并不多。</p>
<p>但如果团队刚成立，通常需要搭建 Git 服务器，在这一节中我们学习如何使用 Gitlab 去搭建 Git 服务器，为了让大家在搭建的时候减少障碍，这里我们使用 Docker 的方式来搭建，因此首先需要安装 Docker。</p>
<h2 id="安装-docker">1 安装 Docker</h2>
<p>安装 Docker 的方式相对简单，直接去 Docker 官网（<a href="http://www.docker.com/">www.docker.com</a>）下载安装包即可，Windows10 以下系统稍微麻烦一些不过电脑的配置建议最少 8G 内存，如果对 Docker 不太理解是什么，可以把它当做是一个简化版的虚拟机，大家可以参考一下这个网址的内容进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.imooc.com&#x2F;article&#x2F;49117</span><br></pre></td></tr></table></figure>
<p>安装 <code>Docker</code> 完毕之后，我们可以通过执行 <code>docker</code> 命令来验证是否安装成功，执行命令如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker</span><br></pre></td></tr></table></figure>
<p>命令执行之后，Docker 返回的信息如下图所示：<img data-src="https://img1.sycdn.imooc.com/5e9d4d330001434017140598.png" alt="图片描述"></p>
<p>在上图中可以看到 Docker 返回的帮助信息，说明我们安装 Docker 已经成功。</p>
<h2 id="下载-gitlab-镜像">2 下载 Gitlab 镜像</h2>
<p>接着我们使用 Docker 去下载 <code>gitlab</code>的镜像，Docker 下载 Gitlab 镜像的命令如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull gitlab&#x2F;gitlab-ce</span><br></pre></td></tr></table></figure>
<p>命令执行完毕之后，Docker 返回的信息如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d3a000141de17140632.png" alt="图片描述"> 在上图中可以看到下载进行已经完成，这个下载的时间会根据你网速来决定，接着我们可以通过查看镜像列表来确认是否下载成功，执行命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>命令执行完毕之后，Docker 返回的镜像列表如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d410001217d17140190.png" alt="图片描述"> 在上图中可以看到<code>gitlab/gitlab-ce</code>这个镜像，说明已经下载到本地了。接着我们先装备几个文件夹，这些文件夹将来要映射到 Gitlab 这个服务中，这样数据便会产生在这几个文件夹里面，将来做数据迁移更方便，建立相关存储文件夹，<code>config</code> 配置文件、<code>logs</code> 日志文件、 <code>data</code> 数据文件，执行的命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/config/gitlab/config</span><br><span class="line">mkdir -p ~/config/gitlab/logs</span><br><span class="line">mkdir -p ~/config/gitlab/data</span><br></pre></td></tr></table></figure>
<p>命令执行完毕之后，我们使用<code>ls</code>命令确认一下，返回的信息文件夹列表如下所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d460001a3fa17140258.png" alt="图片描述"> 在上图中可以看到三个文件夹已经创建成功，他们的绝对路径位于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Users&#x2F;song&#x2F;config&#x2F;gitlab&#x2F;config, </span><br><span class="line">&#x2F;Users&#x2F;song&#x2F;config&#x2F;gitlab&#x2F;logs,</span><br><span class="line">&#x2F;Users&#x2F;song&#x2F;config&#x2F;gitlab&#x2F;data。</span><br></pre></td></tr></table></figure>
<h2 id="运行gitlab容器">3 运行Gitlab容器</h2>
<p>接着，我们就可以使用 Gitlab 镜像来启动容器实例，Gitlab 提供 <code>http</code> 和 <code>https</code> 服务，我们将容器实例的<code>443</code>端口映射到宿主机的<code>8443</code>端口，容器实例的<code>80</code>端口映射到宿主机的<code>8089</code>端口，容器实例的<code>22</code>端口映射到宿主机的<code>2222</code>端口，接着把我们刚才创建好的配置文件夹、日志文件夹、数据文件夹挂载到容器里面去，最终的启动脚本命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --detach --publish 8443:443 --publish 8090:80 --publish 2222:22 --name gitlab --restart always -v &#x2F;Users&#x2F;song&#x2F;config&#x2F;gitlab&#x2F;config:&#x2F;etc&#x2F;gitlab -v &#x2F;Users&#x2F;song&#x2F;config&#x2F;gitlab&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab -v &#x2F;Users&#x2F;song&#x2F;config&#x2F;gitlab&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab gitlab&#x2F;gitlab-ce</span><br></pre></td></tr></table></figure>
<p>命令执行完毕之后，Docker 会启动一个容器实例，并返回容器实例的 id，并在后台执行初始化脚本，如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d500001ab3f15880224.png" alt="图片描述"> 在上图中可以看到一个容器实例的 ID，也可以通过查看容器列表来查看当前有几个容器在运行，查看运行的容器列表命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>命令执行完毕之后，docker返回的容器列表如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONTAINER         ID               IMAGE              COMMAND              CREATED   STATUS                 PORTS     </span><br><span class="line">NAMES</span><br><span class="line">47f3b91c7e3c  gitlab&#x2F;gitlab-ce    &quot;&#x2F;assets&#x2F;wrapper&quot;   28 seconds ago      Up 26 seconds (health: starting)   0.0.0.0:2222-&gt;22&#x2F;tcp, 0.0.0.0:8090-&gt;80&#x2F;tcp, 0.0.0.0:8443-&gt;443&#x2F;tcp   gitlab</span><br></pre></td></tr></table></figure>
<p>在可以看到目前只有一个 Gitlab 容器在运行，我们可以通过<code>docker logs</code>命令查看容器的标准输出日志，执行命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f gitlab</span><br></pre></td></tr></table></figure>
<p>命令执行完毕之后，可以看到初始化的过程，当初始化完成之后，能看到如下图所示的信息： <img data-src="https://img1.sycdn.imooc.com/5e9d4d560001b89417280632.png" alt="图片描述"> 在上图中，可以看到提示服务已经启动完成，在我的电脑中这个过程大约执行了 2 分钟。</p>
<h2 id="gitlab管理配置">4 Gitlab管理配置</h2>
<p>启动完成之后，我们就可以打开 Gitlab 的 web 管理页面进行管理了，在浏览器中输入网址：<code>http://localhost:8090</code>即可进入Gitlab 页面，首次进入管理页面时候，会让你设置 root 用户的密码，如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d5c0001632821121124.png" alt="图片描述"> 在上图中可以看到一个表单，将你需要设置的密码填写进去，然后提交就设置好了账户密码，下次再次登录时候用户名填写<code>root</code>，密码填写刚才设置的密码就可以了，登录进入之后看到的页面如下所示，进去之后是英文界面，如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d620001710321121124.png" alt="图片描述"> 在上图中，可以看到中间有一个<code>Create a project</code>的按钮，我们点击这个按钮就会来到创建仓库的页面，URL 地址为： <code>http://localhost:8090/projects/new</code>，如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d6a00013b8d21121334.png" alt="img"> 在这个页面当中，我们可以填写我们的仓库名称以及相关信息，然后提交表单后，Gitlab 会帮我们新建一个仓库，并会在页面中自动跳转到创建项目的详情页面，如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d730001d2bb21121168.png" alt="图片描述"> 在上图中我们注意看我红色框选出来的内容，这个地址便是给客户端所使用的地址，我们可以用这个地址克隆和推送代码等，我们将这个地址复制出来<code>http://47f3b91c7e3c/root/testgitlab.git</code>，把这个地址中的域名部分改成 IP+ 端口形式就可以给其他电脑访问，我把它域名部分改成<code>localhost:8089</code>之后的地址为：<code>http://localhost:8090/root/testgitlab.git</code>。</p>
<p>接着，我用这个地址克隆一份代码，执行的命令如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;localhost:8090&#x2F;root&#x2F;testgitlab.git</span><br></pre></td></tr></table></figure>
<p>命令执行完毕之后，Git 返回的信息如下图所示。 <img data-src="https://img1.sycdn.imooc.com/5e9d4d78000132a116580326.png" alt="图片描述"> 在上图中可以看到已经成功的克隆出一个仓库，至此已经搭建好自己的<code>gitlab</code>环境了。</p>
<h2 id="gitlab日常维护">5 Gitlab日常维护</h2>
<p>Gitlab 服务搭建好之后，我们后面可能会涉及到一些维护工作，因为使用 Docker 方式搭建的，所以这里我简单提一下一些常用到的文件配置，我们要进入 Gitlab 这个容器(你可以理解为虚拟机)，需要执行命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it gitlab bash</span><br></pre></td></tr></table></figure>
<p>进入这个容器之后，我们可以通过<code>ls</code>命令查看文件列表，如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d7e0001fd9415040224.png" alt="图片描述"> 在上图中，可以看到这些文件夹和宿主机不一致，说明我们已经进入容器成功。在维护 Gitlab 中我们可能会修改配置文件，这个配置文件路径为<code>/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</code>，我们可以大致查看一下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</span><br></pre></td></tr></table></figure>
<p>执行命令之后，返回了末尾 10 行配置，如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d830001b09e15040462.png" alt="图片描述"> 在上图中，可以看到这个配置文件是存在的，我们如果需要修改它通过 vim 编辑即可，在维护服务过程中可能需要启动或停止服务，不过容器里面的各项服务有很多，比如<code>redis</code>、<code>Nginx</code>、<code>grafana</code>等等服务，不过 Gitlab 提供了一个总开关，我们控制总开关即可，命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gitlab-ctl restart  // 重启</span><br><span class="line">gitlab-ctl stop      // 停止</span><br><span class="line">gitlab-ctl start     // 启动</span><br></pre></td></tr></table></figure>
<p>我们以重启服务命令为例，命令执行完毕之后，如下图所示： <img data-src="https://img1.sycdn.imooc.com/5e9d4d880001b34716580632.png" alt="图片描述"> 在上图中，可以看到有很多个服务会进行重启，另外两个命令类似。</p>
<p><a href="https://www.imooc.com/read/51/article/1037">参考连接</a></p>
]]></content>
  </entry>
  <entry>
    <title>在build.gradle中添加系统签名任务</title>
    <url>/2020/09/17/%E5%9C%A8build-gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="在build.gradle中进行系统签名">在build.gradle中进行系统签名</h2>
<h3 id="案例要给apk进行系统签名的时候往往是在命令行中执行">案例：要给apk进行系统签名的时候，往往是在命令行中执行</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;origin -- 要签名的apk</span><br><span class="line">&#x2F;&#x2F;output -- 签名后生成的apk</span><br><span class="line">java -jar .&#x2F;signapk.jar   .&#x2F;platform.x509.pem .&#x2F;platform.pk8  $&#123;origin&#125; $&#123;output&#125;</span><br></pre></td></tr></table></figure>
<p>为了在build.gradle中能直接执行以上签名命令，那么我们只需要在build.gradle中创建一个签名task</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义的Task</span><br><span class="line">task autoSign&#123;</span><br><span class="line">&#x2F;&#x2F;这个task执行会在assembleDebug之后执行</span><br><span class="line">    dependsOn&#39;assembleDebug&#39;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        &#x2F;&#x2F;签名包的输出目录，如果该目录不存在，需要提前创建</span><br><span class="line">        def outputDir&#x3D;project.rootDir.absolutePath+&quot;&#x2F;apk&#x2F;&quot; </span><br><span class="line">        &#x2F;&#x2F;签名文件目录</span><br><span class="line">        def inches21Dir&#x3D;project.rootDir.absolutePath+&quot;&#x2F;security&quot; &#x2F;&#x2F;存放签名文件的目录，为当前项目下的security文件夹中</span><br><span class="line">        android.applicationVariants.all&#123;variant-&gt;</span><br><span class="line">            variant.outputs.all&#123;output-&gt;</span><br><span class="line">                &#x2F;&#x2F;获取多渠道的名字</span><br><span class="line">                def channel</span><br><span class="line">                variant.productFlavors.each&#123;product-&gt;</span><br><span class="line">                    channel&#x3D;product.name</span><br><span class="line">                    &#125;</span><br><span class="line">                &#x2F;&#x2F;获取apk打包出来的文件output.outputFile</span><br><span class="line">                def exist&#x3D;output.outputFile.exists()</span><br><span class="line">                if(exist &amp;&amp; channel &#x3D;&#x3D; &quot;common&quot;)&#123; &#x2F;&#x2F;指定只生成某个产品</span><br><span class="line">                    &#x2F;&#x2F;签名之后的apk名字</span><br><span class="line">                    def name&#x3D;&quot;signed_&quot;+output.outputFile.getName()</span><br><span class="line">                    &#x2F;&#x2F;apk打包所在的目录</span><br><span class="line">                    def apk&#x3D;output.outputFile.getPath()</span><br><span class="line">                    &#x2F;&#x2F;根据不同渠道获取对于的.sh文件路径</span><br><span class="line">                    def wDir&#x3D;&quot;&quot;,shPath&#x3D;&quot;&quot;</span><br><span class="line"></span><br><span class="line">                        wDir&#x3D;inches21Dir</span><br><span class="line">                        shPath&#x3D;inches21Dir+&quot;&#x2F;signapk.sh&quot;</span><br><span class="line"></span><br><span class="line">                    println(&quot;-----------------------------------&quot;)</span><br><span class="line">                    println(&quot;签名文件脚本：&quot;+shPath)</span><br><span class="line">                    println(&quot;开始签名：&quot;+channel+&quot;......&quot;)</span><br><span class="line">                    exec&#123;</span><br><span class="line">                        &#x2F;&#x2F;切换到sh文件所在的目录，执行脚本</span><br><span class="line">                        workingDir wDir</span><br><span class="line">                        &#x2F;&#x2F;执行shell脚本&quot;,&quot;传参</span><br><span class="line">                        commandLine&quot;sh&quot;,shPath,apk, outputDir+name</span><br><span class="line">                        &#125;</span><br><span class="line">                    println(&quot;签名成功，文件保存至：&quot;+name)</span><br><span class="line">                    println(&quot;-----------------------------------&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在android studio的Gradle中找到该任务执行即可，在projectdir/apk目录下就会生成 singed_xxx_xxx.apk,</p>
<p>以上signapk.sh脚本的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># apk源文件路径</span><br><span class="line">origin&#x3D;$1</span><br><span class="line">output&#x3D;$2</span><br><span class="line">java -jar .&#x2F;signapk.jar   .&#x2F;platform.x509.pem .&#x2F;platform.pk8  $&#123;origin&#125; $&#123;output&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>page</title>
    <url>/2020/09/11/docs/getting-started/index/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>page</title>
    <url>/2020/09/11/docs/getting-started/installation/</url>
    <content><![CDATA[<p>hahah</p>
]]></content>
  </entry>
</search>
